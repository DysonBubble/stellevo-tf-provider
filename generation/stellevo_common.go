package main
import (
  "fmt"
	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	"strings"
	"sort"
	"os"
)

func DoMain(generationKind string, provider string, resources map[string]*schema.Resource) {
	switch generationKind {
		case "inputs":
			PrintInputTS(provider, resources, TS_SCHEMA_INPUT_SENSITIVE_STRING)
			break
		case "outputs":
			PrintOutputTS(resources)
			break
		case "resources":
			fmt.Println(GetTSResourcesLookupValue(resources, TS_ALL_RESOURCES_VAR_NAME))
			break
		case "codegen":
			fmt.Println(GetTSForCodeGenerationCallback(provider))
			break
		case "projectfile":
			fmt.Println(GetProjectFileContents(os.Args[2], os.Args[3:]))
			break
		default:
			panic(fmt.Sprintf("Unrecognized generation kind %s", generationKind))
	}
}

func PrintInputTS(provider string, resources map[string]*schema.Resource, sensitiveStringSchemaName string) {
	fmt.Println(GetTSInputPrelude(provider, resources ))
	sortedKeys := SortedStringKeys(resources)
  for _, res_id := range sortedKeys {
    fmt.Println(TFResourceToTSInputType(res_id, resources[res_id], sensitiveStringSchemaName))
	}
	fmt.Println(GetTSInputPostlude(resources))
}

func PrintOutputTS(resources map[string]*schema.Resource) {
	fmt.Println(GetTSOutputPrelude( resources ))
	sortedKeys := SortedStringKeys(resources)
  for _, res_id := range sortedKeys {
    fmt.Println(TFResourceToTSOutputType(res_id, resources[res_id]))
	}
	fmt.Println(GetTSOutputPostlude(resources))
}

// func PrintResourcesTS(resources map[string]*schema.Resource) {
// 	fmt.Println(GetTSResourcesPrelude())
// 	for res_id, res := range resources {
//     fmt.Println(TFResourceToTSDeclaration(res_id, res))
// 	}
// 	fmt.Println(GetTSResourcesPostlude())
// }

func GetTSInputPrelude(provider string, resources map[string]*schema.Resource) string {
	return fmt.Sprintf("// THIS FILE IS AUTOGENERATED BY GO SCRIPT\n\nimport * as " + TS_PLATFORM_API_IMPORT_NAME + " from '../../../common/platforms/resources';\nimport * as " + TS_PROVIDER_RESOURCES_IMPORT_NAME + " from '../resources/';\nimport * as " + TS_SCHEMA_COMMON_IMPORT_NAME + " from '../../../common/providers/schemas';\n%s\n%s\n%s %s", ProviderSpecificInputPrelude(), GetTSInputOrOutputLookupType(resources, TS_ALL_RESOURCES_TYPE_NAME), "export const " + TS_SCHEMA_INPUT_SENSITIVE_STRING + " = ", ProviderSpecificSensitiveStringSchemaDefinition(TS_SCHEMA_INPUT_SENSITIVE_STRING_NAME))
}

func GetTSInputPostlude(resources map[string]*schema.Resource) string {
	// This has to be in postlude, as we need to actually create schemas before referencing them
	return GetTSInputOrOutputLookupVar(resources, TS_ALL_SCHEMAS_VAR_NAME)
}

// func GetTSResourcesPrelude() string {
// 	return "export type TResourceInfo<TInputs extends string, TOutputs extends string> = { inputs: TInputs; outputs: TOutputs; };\nexport type TSupportedResources = {\n"
// }

// func GetTSResourcesPostlude() string {
// 	return "}"
// }

func GetTSOutputPrelude(resources map[string]*schema.Resource) string {
	return fmt.Sprintf("// THIS FILE IS AUTOGENERATED BY GO SCRIPT\n\nimport * as " + TS_PLATFORM_API_IMPORT_NAME + " from '../../../common/platforms/resources';\nimport * as " + TS_SCHEMA_COMMON_IMPORT_NAME + " from '../../../common/providers/schemas';\n%s", GetTSInputOrOutputLookupType(resources, TS_ALL_RESOURCES_TYPE_NAME))
}

func GetTSOutputPostlude(resources map[string]*schema.Resource) string {
	// This has to be in postlude, as we need to actually create schemas before referencing them
	return GetTSInputOrOutputLookupVar(resources, TS_ALL_SCHEMAS_VAR_NAME)
}

// func TFResourceToTSDeclaration(res_id string, res *schema.Resource) string {
// 	return fmt.Sprintf("  %q: TResourceInfo<%s,%s>;\n", res_id, GetTResourceInfoPropertyNames(res, true), GetTResourceInfoPropertyNames(res, false))
// }

func TFResourceToTSInputType(res_id string, res *schema.Resource, sensitiveStringSchemaName string) string {
	// fmt.Println("DEBUG: %s", res_id)
  return fmt.Sprintf("export const %s = %s;\nexport type %s = common.TypeOf<typeof %s>", res_id, GetRecordSchemaContentString(res_id, make([]string, 0), res.Schema, true, sensitiveStringSchemaName, TS_SCHEMA_RESOURCE_NAME), res_id, res_id)
}

func TFResourceToTSOutputType(res_id string, res *schema.Resource) string {
	return fmt.Sprintf("export const %s = %s;\nexport type %s = common.TypeOf<typeof %s>", res_id, GetRecordSchemaContentString(res_id, make([]string, 0), res.Schema, false, "", TS_SCHEMA_RESOURCE_NAME), res_id, res_id)
}

func GetTSInputOrOutputLookupType(resources map[string]*schema.Resource, typeName string) string {
	return GetTSInputOrOutputLookupVarOrType(resources, typeName, "type", ";", "", func(res_id string) string {
		return res_id
	} )
}

func GetTSInputOrOutputLookupVar(resources map[string]*schema.Resource, varName string) string {
	return GetTSInputOrOutputLookupVarOrType(resources, varName, "const", ",", " as const", func(res_id string) string {
		return fmt.Sprintf(TS_SCHEMA_MAP + "(%s)", res_id)
	})
}

func GetTSInputOrOutputLookupVarOrType(resources map[string]*schema.Resource, typeOrVarName string, kind string, separator string, suffix string, valueCallback func(res_id string) string) string {
	ret := fmt.Sprintf("export %s %s = {\n", kind, typeOrVarName)
	for res_id, _ := range resources {
		ret = fmt.Sprintf("%s  %q: %s%s\n", ret, res_id, valueCallback(res_id), separator)
	}
	return fmt.Sprintf("%s}%s;\n", ret, suffix)
}

func GetTSResourcesLookupValue(resources map[string]*schema.Resource, varName string) string {
	ret := fmt.Sprintf("// THIS FILE IS AUTOGENERATED BY GO SCRIPT\n\nexport const %s = {\n", varName)
	for res_id, _ := range resources {
		ret = fmt.Sprintf("%s  %q: %q,\n", ret, res_id, res_id)
	}
	return fmt.Sprintf("%s} as const;\n", ret)
}

func GetTResourceInfoPropertyNames(res *schema.Resource, isInput bool) string {
	keys := []string{}
	for k, v := range res.Schema {
    if (IsInputSchema(v) == isInput) {
			keys = append(keys,fmt.Sprintf("%q", k))
		}
	}
	return strings.Join(keys, "|")
}

func TFSchemaToTSType( resource_id string, path []string, s *schema.Schema, isInput bool, parentIsSensitive bool, sensitiveStringSchemaName string ) string {
  switch s.Type {
    case schema.TypeString:
			customSchema := TryGetProviderSpecificStringSchema(isInput, resource_id, path)
			if len(customSchema) > 0 {
				return customSchema
			} else if len(sensitiveStringSchemaName) > 0 && (parentIsSensitive || s.Sensitive) {
				return sensitiveStringSchemaName
			} else {
				return TS_SCHEMA_STRING
			}
    case schema.TypeBool:
      return TS_SCHEMA_BOOL
		case schema.TypeInt:
			return TS_SCHEMA_INT
		case schema.TypeFloat:
      return TS_SCHEMA_FLOAT
    case schema.TypeMap:
      return fmt.Sprintf("%s(%s)", TS_SCHEMA_MAP, GetElemSchemaString(resource_id, path, s, isInput, sensitiveStringSchemaName))
    case schema.TypeSet:
      return GetArraySchemaString(s, GetElemSchemaString(resource_id, path, s, isInput, sensitiveStringSchemaName), TS_SCHEMA_SET)
    case schema.TypeList:
      return GetArraySchemaString(s, GetElemSchemaString(resource_id, path, s, isInput, sensitiveStringSchemaName), TS_SCHEMA_LIST)
    default:
      panic(fmt.Errorf("invalid schema Type %s", s.Type))
  }
}

func GetElemSchemaString( resource_id string, path []string, s *schema.Schema, isInput bool, sensitiveStringSchemaName string) string {
  switch set := s.Elem.(type) {
		case nil: // Does not happen for azurerm provider (technically not legal situation, according to documentation in https://github.com/hashicorp/terraform-plugin-sdk/blob/master/helper/schema/schema.go )
			return "common.SchemaAny"
    case *schema.Schema:
      return TFSchemaToTSType(resource_id, path, set, isInput, s.Sensitive, sensitiveStringSchemaName)
    case *schema.Resource:
			return GetRecordSchemaContentString(resource_id, path, set.Schema, isInput, sensitiveStringSchemaName, TS_SCHEMA_BLOCK_NAME)
		case schema.ValueType: // Does not happen for azurerm provider (technically not legal situation, according to documentation in https://github.com/hashicorp/terraform-plugin-sdk/blob/master/helper/schema/schema.go )
		  switch set {
				case schema.TypeString:
					customSchema := TryGetProviderSpecificStringSchema(isInput, resource_id, path)
					if len(customSchema) > 0 {
						return customSchema
					} else if len(sensitiveStringSchemaName) > 0 && s.Sensitive {
  					return sensitiveStringSchemaName
					} else {
						return TS_SCHEMA_STRING
					}
				case schema.TypeBool:
					return TS_SCHEMA_BOOL
				case schema.TypeInt:
					return TS_SCHEMA_INT
				case schema.TypeFloat:
					return TS_SCHEMA_FLOAT
				default:
					panic(fmt.Errorf("invalid element schema value type %s", set))
			}
    default:
      panic(fmt.Errorf("invalid element schema type %s", set))
  }
}

func GetArraySchemaString( s *schema.Schema, typeString string, tsArrayType string ) string {
	// var actualType string

  if ( s.MaxItems == 1 ) {
		return typeString
		// actualType = tsSingleElementType
    //return fmt.Sprintf("%s<%s>", tsSingleElementType, typeString)
  } else {
    return fmt.Sprintf("%s(%s)", tsArrayType, typeString)
		// actualType = tsArrayType
//    return fmt.Sprintf("%s<%s>", tsArrayType, typeString)
  }
}

func GetRecordSchemaContentString( resource_id string, path []string, props map[string]*schema.Schema, isInput bool, sensitiveStringSchemaName string, resultSchemaName string ) string {
	// var ret = "{\n"
	var required = ""
	var optional = ""
	sortedKeys := SortedStringKeysSchema(props)
  for _, prop_name := range sortedKeys {
		prop_schema := props[prop_name]
    if (IsInputSchema(prop_schema) == isInput) {
			// fmt.Println("DEBUG 2 %s", prop_name)
			var cur = fmt.Sprintf("%q", prop_name)
			var curSchema = TFSchemaToTSType(resource_id, append(path, prop_name), prop_schema, isInput, false, sensitiveStringSchemaName)
			if (prop_schema.Required) {
				required = fmt.Sprintf("%s%s: %s,\n", required, cur, curSchema)
			} else {
				optional = fmt.Sprintf("%s%s: %s,\n", optional, cur, curSchema)
			}
    }
	}
	var retVal string
	if (len(required) > 0 && len(optional) > 0) {
    retVal = fmt.Sprintf("  common.SchemaIntersection( [common.SchemaRecord({\n%s\n  }), common.SchemaOptional({\n%s\n  })]", required, optional)
	} else if (len(required) > 0) {
    retVal = fmt.Sprintf("  common.SchemaRecord({\n%s\n  }", required)
	} else {
		retVal = fmt.Sprintf("  common.SchemaOptional({\n%s\n  }", optional)
	}

	if (len(resultSchemaName) > 0) {
		retVal = fmt.Sprintf("%s, %s", retVal, resultSchemaName)
	}
	return fmt.Sprintf("%s)", retVal)
}

func IsInputSchema(s *schema.Schema) bool {
	return s.Computed != true || s.Optional == true //.ValidateFunc != nil
}

func SortedStringKeys(m map[string]*schema.Resource) ([]string) {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
			keys[i] = k
			i++
	}
	sort.Strings(keys)
	return keys
}

// For some reason map[string]*interface{} doesn't accept map[string]*schema.Resource (or even just map[string]interface{}), I don't know why, Go is a fucked-up language.
func SortedStringKeysSchema(m map[string]*schema.Schema) ([]string) {
	keys := make([]string, len(m))
	i := 0
	for k := range m {
			keys[i] = k
			i++
	}
	sort.Strings(keys)
	return keys
}

func GetTSForCodeGenerationCallback(provider string) string {
	return `// THIS FILE IS AUTOGENERATED BY GO SCRIPT

import * as ` + TS_SCHEMA_INPUT_IMPORT_NAME + ` from "../../../api/providers/` + provider + `/schemas/inputs";
import * as ` + TS_CODEGEN_COMMON_IMPORT_NAME +` from "../../common/providers";

export const HandleProviderSpecificSchema: (` + TS_CODEGEN_CALLBACK_SCHEMA_VALUE + `: ` + TS_CODEGEN_COMMON_IMPORT_NAME + `.TProviderSpecificSchema, ` + TS_CODEGEN_CALLBACK_PARAMETER_VALUE + `: unknown) => ` + TS_CODEGEN_COMMON_IMPORT_NAME + `.SchemaHandlingResult = (` + TS_CODEGEN_CALLBACK_SCHEMA_VALUE + `, ` + TS_CODEGEN_CALLBACK_PARAMETER_VALUE + `) => {
	switch ( ` + TS_CODEGEN_CALLBACK_SCHEMA_VALUE + `.name) {
		` + GetProviderSpecificUnionSchemaCodeGenHandling() + `
		default:
			throw new Error("The provider ` + provider + ` does not support schema " + ` + TS_CODEGEN_CALLBACK_SCHEMA_VALUE + `.name + "." );
	}
};`
}

func GetProjectFileContents(pathToRoot string, subdirs []string) string {
	// No proper map/reduce in language like Go so we have to do manual for looping and such...
	retVal := `{
  "extends": "` + pathToRoot + `/tsconfig.project.json",
  "include": [
    "./*.ts"
  ],
  "compilerOptions": {
    "composite": true,
    "outDir": "` + pathToRoot + `/ts_out"
  },
  "references": [
    `
	rawProviders := GetProvidersThisDependsOn()
	providers := make([]string, len(rawProviders))
	for refIdx, provider := range rawProviders {
		references := make([]string, 0)
		for _, dir := range subdirs {
			if (!strings.HasPrefix(dir, ".")) {
				// Use directory as sub-directory of another provider
				references = append(references, fmt.Sprintf(`{ "path": "../../%s/%s" }`, provider, dir))
			}
		}
		providers[refIdx] = strings.Join(references, ",")
	}
	for _, dir := range subdirs {
		if (strings.HasPrefix(dir, ".")) {
			// Use directory as-is
			providers = append(providers, fmt.Sprintf(`{ "path": "%s" }`, dir))
		}
	}

	return fmt.Sprintf(`%s%s
  ]
}`, retVal, strings.Join(providers, ",\n    "))

}

const TS_SCHEMA_COMMON_IMPORT_NAME = "common"
const TS_SCHEMA_PREFIX = TS_SCHEMA_COMMON_IMPORT_NAME + ".Schema"
const TS_SCHEMA_STRING = TS_SCHEMA_PREFIX + "String"
const TS_SCHEMA_INPUT_SENSITIVE_STRING = "SchemaSensitiveString"
const TS_SCHEMA_INPUT_SENSITIVE_STRING_NAME = "common.SchemaSensitiveStringName"
const TS_SCHEMA_BOOL = TS_SCHEMA_PREFIX + "Boolean"
const TS_SCHEMA_INT = TS_SCHEMA_PREFIX + "Integer"
const TS_SCHEMA_FLOAT = TS_SCHEMA_PREFIX + "Real"
const TS_SCHEMA_MAP = TS_SCHEMA_PREFIX + "Map"
const TS_SCHEMA_SET = TS_SCHEMA_PREFIX + "Set"
const TS_SCHEMA_LIST = TS_SCHEMA_PREFIX + "List"
const TS_ALL_RESOURCES_TYPE_NAME = "TAllResources"
const TS_ALL_RESOURCES_VAR_NAME = "AllResources"
const TS_PLATFORM_API_IMPORT_NAME = "platform"
const TS_PROVIDER_RESOURCES_IMPORT_NAME = "resources"
const TS_ALL_SCHEMAS_VAR_NAME = "AllSchemas"
const TS_SCHEMA_BLOCK_NAME = TS_SCHEMA_COMMON_IMPORT_NAME + ".BlockSchemaName"
const TS_SCHEMA_RESOURCE_NAME = TS_SCHEMA_COMMON_IMPORT_NAME + ".ResourceSchemaName"

const TS_SCHEMA_INPUT_IMPORT_NAME = "provider_inputs"
const TS_CODEGEN_CALLBACK_SCHEMA_VALUE = "provider_schema"
const TS_CODEGEN_CALLBACK_PARAMETER_VALUE = "value"
const TS_CODEGEN_RETVAL_KIND_INDIRECT = "indirect"
const TS_CODEGEN_RETVAL_KIND_DIRECT = "direct"
const TS_CODEGEN_RETVAL_KIND_NAME = "kind"
const TS_CODEGEN_RETVAL_VALUE_NAME = "value"
const TS_CODEGEN_RETVAL_SCHEMA_NAME = "schema"
const TS_CODEGEN_COMMON_IMPORT_NAME = "common"